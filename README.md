# Coroutine
协程 (`Coroutine`) 是由应用程序调度的用户态线程, 是一种绿色线程 (`Green Thread`) 。使用协程可以实现单线程的异步。这个仓库实现了 `x86` (包含 `32` 位和 `64` 位) 平台的协程。可在 `GCC 11.2` 及以下的 `GCC` 编译器上编译。

# 使用
本库使用只需要引入头文件 `coroutine.h` 。

## 函数类型
为了能够适配多种函数, 本库调度的协程函数声明应为:

```C
void* foo(void* args);
```

传递参数的时候, 结构体必须通过指针传递, 而基础类型可以通过强转为 `void*` 类型传递, 但可能会触发编译器警告。

## 创建协程
可以通过函数 `co_start` 启动一个协程:

```C
void* foo(void*) {
    // ...
}

Coroutine foo_routine = co_start(foo, args);
```

协程被创建后就会进入待调度状态, 等待调度 。

## yield
可以通过 `co_yield` 函数, 将控制权主动交给调度器, 调度器会切换到其它的 `Coroutine` 中运行:

```C
void* foo(void*) {
    // ...
    co_yield(); // --------------------------
    // ...      //                          |
}               //                          |
//                                          |
//                        -----------       |
//                   -----| excutor | <-----|
//                   |    -----------
//                   |
//                   |
void* bar(void*) {// |
    // ...           |
    co_yield();//    |
    // ...        <---
}

```

## 等待协程结束 (获取协程返回值)
可以通过函数 `co_wait` 来等待协程结束, 并获取返回值:

```C
void *ret = co_wait(foo_routine);
```

**注意：不通过 `co_wait` 等待协程结束, 而协程又没有被销毁的话, 会造成内存泄漏**

## 取消协程 (销毁协程)
可以通过函数 `co_cancel` 取消 (或者说) 销毁一个协程:

```C
co_cancel(foo_routine);
// foo_routine 被销毁, 不会再被调度
```

## 示例代码
`example.c` 中是示例代码。